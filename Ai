import tkinter as tk
from tkinter import filedialog, messagebox
import heapq, math

NODE_R = 12
COLORS = {
    'default': '#AED6F1', 'visited': '#B2BABB', 'frontier': '#F7DC6F',
    'current': '#E74C3C', 'path': '#2ECC71', 'start': '#3498DB', 'goal': '#9B59B6'
}

class GraphApp:
    def __init__(self, root):
        self.root = root
        self.root.title("A* / GBFS Wizualizator")
        self.canvas = tk.Canvas(root, bg='white')
        self.canvas.pack(side='right', fill='both', expand=True)
        self.controls = tk.Frame(root, padx=5, pady=5)
        self.controls.pack(side='left', fill='y')

        # Przyciski i pola wejściowe
        tk.Button(self.controls, text="Wczytaj graf", command=self.load_graph).pack(fill='x', pady=2)
        tk.Label(self.controls, text="Start:").pack()
        self.start_e = tk.Entry(self.controls); self.start_e.pack(fill='x')
        tk.Label(self.controls, text="Cel:").pack()
        self.goal_e = tk.Entry(self.controls); self.goal_e.pack(fill='x')
        self.alg = tk.StringVar(value="A*")
        for name in ["A*", "GBFS"]:
            tk.Radiobutton(self.controls, text=name, variable=self.alg, value=name).pack(anchor='w')
        tk.Button(self.controls, text="Start", command=self.start).pack(fill='x', pady=5)
        tk.Button(self.controls, text="Krok dalej", command=self.step).pack(fill='x')
        self.status = tk.Label(self.controls, text="Wczytaj graf")
        self.status.pack(fill='x', pady=5)

        # Dane grafu
        self.graph = []; self.coords = []; self.n = 0
        self.gen = None
        self.s = None
        self.g = None

    def load_graph(self):
        f = filedialog.askopenfilename(filetypes=[("Plik txt", "*.txt")])
        if not f: return
        try:
            with open(f) as file:
                self.n = int(file.readline())
                self.coords = [tuple(map(int, file.readline().split())) for _ in range(self.n)]
                self.graph = []
                for _ in range(self.n):
                    parts = file.readline().split()
                    if len(parts) > 1:
                        self.graph.append([int(v)-1 for v in parts[1:]])
                    else:
                        self.graph.append([])
            self.status.config(text=f"Wczytano {self.n} wierzchołków")
            self.draw()
        except Exception as e:
            messagebox.showerror("Błąd", str(e))

    def coord(self, i):
        x, y = self.coords[i]; return 40 + x*60, 40 + y*60

    def draw(self, cur=-1, visited=set(), front=set(), path=[]):
        self.canvas.delete('all')
        # Krawędzie
        for i in range(self.n):
            x1, y1 = self.coord(i)
            for j in self.graph[i]:
                if j > i:
                    x2, y2 = self.coord(j)
                    self.canvas.create_line(x1, y1, x2, y2, fill="#ccc", width=2)
        # Ścieżka
        for a, b in zip(path, path[1:]):
            x1, y1 = self.coord(a); x2, y2 = self.coord(b)
            self.canvas.create_line(x1, y1, x2, y2, fill=COLORS['path'], width=4)
        # Wierzchołki
        for i in range(self.n):
            x, y = self.coord(i)
            color = 'default'
            if i in path: color = 'path'
            elif i == cur: color = 'current'
            elif i in front: color = 'frontier'
            elif i in visited: color = 'visited'
            if self.s is not None and i == self.s: color = 'start'
            if self.g is not None and i == self.g: color = 'goal'
            self.canvas.create_oval(x-NODE_R, y-NODE_R, x+NODE_R, y+NODE_R,
                                    fill=COLORS[color], outline='black')
            self.canvas.create_text(x, y, text=str(i+1), font=('Arial', 10, 'bold'))

    def start(self):
        try:
            self.s = int(self.start_e.get()) - 1
            self.g = int(self.goal_e.get()) - 1
        except:
            messagebox.showerror("Błąd", "Podaj poprawne numery"); return
        self.gen = self.search()
        self.status.config(text=f"Algorytm: {self.alg.get()}")

    def step(self):
        if not self.gen: return
        try:
            state = next(self.gen)
            if state['status'] == 'running':
                self.draw(state['current'], state['visited'], state['frontier'])
            elif state['status'] == 'found':
                self.draw(path=state['path'])
                self.status.config(text=f"Znaleziono! Koszt: {state['cost']:.2f}")
        except StopIteration:
            pass

    def dist(self, a, b):
        x1, y1 = self.coords[a]; x2, y2 = self.coords[b]
        return math.hypot(x1-x2, y1-y2)

    def search(self):
        alg = self.alg.get()
        q = [(0, self.s)]
        came, cost = {self.s: None}, {self.s: 0}
        visited = set()
        while q:
            _, cur = heapq.heappop(q)
            if cur in visited: continue
            visited.add(cur)
            yield {'status':'running','current':cur,'visited':visited,'frontier':{n for _,n in q}}
            if cur == self.g:
                path=[]; c=cur
                while c is not None: path.append(c); c=came[c]
                path.reverse()
                yield {'status':'found','path':path,'cost':cost[cur]}
                return
            for n in self.graph[cur]:
                new = cost[cur] + self.dist(cur, n)
                if n not in cost or new < cost[n]:
                    cost[n] = new; came[n] = cur
                    f = new + self.dist(n, self.g) if alg == "A*" else self.dist(n, self.g)
                    heapq.heappush(q, (f, n))
        messagebox.showinfo("Brak", "Nie znaleziono ścieżki")

if __name__ == "__main__":
    root = tk.Tk()
    GraphApp(root)
    root.mainloop()
