import tkinter as tk
from tkinter import filedialog, messagebox
import heapq, math

NODE_R = 12
COLORS = {
    'default': '#AED6F1', 'visited': '#B2BABB', 'frontier': '#F7DC6F',
    'current': '#E74C3C', 'path': '#2ECC71', 'start': '#3498DB', 'goal': '#9B59B6'
}

class GraphApp:
    def __init__(self, root):
        self.root = root
        self.root.title("A* / GBFS Wizualizator")
        self.canvas = tk.Canvas(root, bg='white')
        self.canvas.pack(side='right', fill='both', expand=True)
        self.controls = tk.Frame(root, padx=5, pady=5)
        self.controls.pack(side='left', fill='y')

        tk.Button(self.controls, text="Wczytaj graf", command=self.load_graph).pack(fill='x', pady=2)
        self.start_e, self.goal_e = tk.Entry(self.controls), tk.Entry(self.controls)
        tk.Label(self.controls, text="Start:").pack(); self.start_e.pack(fill='x')
        tk.Label(self.controls, text="Cel:").pack(); self.goal_e.pack(fill='x')
        self.alg = tk.StringVar(value="A*")
        for name in ["A*", "GBFS"]:
            tk.Radiobutton(self.controls, text=name, variable=self.alg, value=name).pack(anchor='w')
        tk.Button(self.controls, text="Start", command=self.start).pack(fill='x', pady=5)
        tk.Button(self.controls, text="Krok dalej", command=self.step).pack(fill='x')
        self.status = tk.Label(self.controls, text="Wczytaj graf")
        self.status.pack(fill='x', pady=5)

        self.graph = []; self.coords = []; self.n = 0
        self.gen = None

    def load_graph(self):
        f = filedialog.askopenfilename(filetypes=[("Plik txt", "*.txt")])
        if not f: return
        try:
            with open(f) as file:
                self.n = int(file.readline())
                self.coords = [tuple(map(int, file.readline().split())) for _ in range(self.n)]
                self.graph = [[int(v)-1 for v in file.readline().split()[1:]] for _ in range(self.n)]
            self.status.config(text=f"Wczytano {self.n} wierzchołków")
            self.draw()
        except Exception as e:
            messagebox.showerror("Błąd", str(e))

    def coord(self, i):
        x, y = self.coords[i]; return 40 + x*60, 40 + y*60

    def draw(self, cur=-1, visited=set(), front=set(), path=[]):
        self.canvas.delete('all')
        # krawędzie
        for i in range(self.n):
            x1, y1 = self.coord(i)
            for j in self.graph[i]:
                if j > i:
                    x2, y2 = self.coord(j)
                    self.canvas.create_line(x1, y1, x2, y2, fill="#ccc", width=2)
        # ścieżka
        for a, b in zip(path, path[1:]):
            x1, y1 = self.coord(a); x2, y2 = self.coord(b)
            self.canvas.create_line(x1, y1, x2, y2, fill=COLORS['path'], width=4)
        # wierzchołki
        for i in range(self.n):
            x, y = self.coord(i)
            color = 'default'
            if i in path: color = 'path'
            elif i == cur: color = 'current'
            elif i in front: color = 'frontier'
            elif i in visited: color = 'visited'
            if i == self.s: color = 'start'
            if i == self.g: color = 'goal'
            self.canvas.create_oval(x-NODE_R, y-NODE_R, x+NODE_R, y+NODE_R,
                                    fill=COLORS[color], outline='black')
            self.canvas.create_text(x, y, text=str(i+1), font=('Arial', 10, 'bold'))

    def start(self):
        try:
            self.s = int(self.start_e.get()) - 1
            self.g = int(self.goal_e.get()) - 1
        except: 
            messagebox.showerror("Błąd", "Podaj poprawne numery"); return
        self.gen = self.search()
        self.status.config(text=f"Algorytm: {self.alg.get()}")

    def step(self):
        if not self.gen: return
        try:
            state = next(self.gen)
            if state['status'] == 'running':
                self.draw(state['current'], state['visited'], state['frontier'])
            elif state['status'] == 'found':
                self.draw(path=state['path'])
                self.status.config(text=f"Znaleziono! Koszt: {state['cost']:.2f}")
        except StopIteration:
            pass

    def dist(self, a, b):
        x1, y1 = self.coords[a]; x2, y2 = self.coords[b]
        return math.hypot(x1-x2, y1-y2)

    def search(self):
        alg = self.alg.get()
        q = [(0, self.s)]
        came, cost = {self.s: None}, {self.s: 0}
        visited = set()
        while q:
            _, cur = heapq.heappop(q)
            if cur in visited: continue
            visited.add(cur)
            yield {'status':'running','current':cur,'visited':visited,'frontier':{n for _,n in q}}
            if cur == self.g:
                path=[]; c=cur
                while c is not None: path.append(c); c=came[c]
                path.reverse()
                yield {'status':'found','path':path,'cost':cost[cur]}
                return
            for n in self.graph[cur]:
                new = cost[cur] + self.dist(cur, n)
                if n not in cost or new < cost[n]:
                    cost[n] = new; came[n] = cur
                    f = new + self.dist(n, self.g) if alg == "A*" else self.dist(n, self.g)
                    heapq.heappush(q, (f, n))
        messagebox.showinfo("Brak", "Nie znaleziono ścieżki")

if __name__ == "__main__":
    root = tk.Tk()
    GraphApp(root)
    root.mainloop()






import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import heapq
import math

# --- Stałe ---
NODE_RADIUS = 12
SCALE = 60
PADDING = 40

# Użycie słownika dla kolorów jest "łatwiejsze" w zarządzaniu
STATE_COLORS = {
    'default': '#AED6F1',   # Jasnoniebieski
    'visited': '#B2BABB',   # Szary
    'frontier': '#F7DC6F',  # Żółty
    'current': '#E74C3C',   # Czerwony
    'path': '#2ECC71',      # Zielony
    'start': '#3498DB',     # Ciemnoniebieski
    'goal': '#9B59B6',      # Fioletowy
}
LINE_COLOR = '#EAECEE'
PATH_LINE_COLOR = '#28B463'

class GraphSearchApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Wizualizator Przeszukiwania Grafu")
        self.root.geometry("1000x750")

        # --- Inicjalizacja stanu ---
        self.num_nodes = 0
        self.coordinates = []
        self.adj_list = []
        self.search_generator = None
        self.start_idx = -1
        self.goal_idx = -1

        # --- Konfiguracja GUI ---
        self._setup_gui()

    def _setup_gui(self):
        """Tworzy wszystkie elementy interfejsu użytkownika."""
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # 1. Panel kontrolny (lewy)
        control_panel = ttk.Frame(main_frame, width=250)
        control_panel.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)

        # 2. Płótno (prawe)
        canvas_frame = ttk.Frame(main_frame)
        canvas_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        self.canvas = tk.Canvas(canvas_frame, bg='white', relief=tk.SUNKEN)
        self.canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=10)

        # --- Elementy panelu kontrolnego ---
        
        # Sekcja 1: Plik
        load_frame = ttk.LabelFrame(control_panel, text="1. Graf")
        load_frame.pack(fill=tk.X, pady=5)
        self.load_button = ttk.Button(load_frame, text="Wczytaj graf...", command=self.load_graph)
        self.load_button.pack(fill=tk.X, margin=5)
        self.graph_label = ttk.Label(load_frame, text="Nie wczytano grafu.")
        self.graph_label.pack(fill=tk.X, margin=5)

        # Sekcja 2: Wybór
        select_frame = ttk.LabelFrame(control_panel, text="2. Wierzchołki (numery 1-N)")
        select_frame.pack(fill=tk.X, pady=5)
        ttk.Label(select_frame, text="Start:").pack(anchor=tk.W)
        self.start_entry = ttk.Entry(select_frame)
        self.start_entry.pack(fill=tk.X, margin=2)
        ttk.Label(select_frame, text="Cel:").pack(anchor=tk.W)
        self.goal_entry = ttk.Entry(select_frame)
        self.goal_entry.pack(fill=tk.X, margin=2)

        # Sekcja 3: Algorytm
        algo_frame = ttk.LabelFrame(control_panel, text="3. Algorytm")
        algo_frame.pack(fill=tk.X, pady=5)
        self.algo_var = tk.StringVar(value="A*")
        ttk.Radiobutton(algo_frame, text="A* (f = g + h)", variable=self.algo_var, value="A*").pack(anchor=tk.W)
        ttk.Radiobutton(algo_frame, text="Zachłanny (f = h)", variable=self.algo_var, value="GBFS").pack(anchor=tk.W)

        # Sekcja 4: Sterowanie
        run_frame = ttk.LabelFrame(control_panel, text="4. Sterowanie")
        run_frame.pack(fill=tk.X, pady=5)
        self.start_button = ttk.Button(run_frame, text="Uruchom", command=self.start_search, state=tk.DISABLED)
        self.start_button.pack(fill=tk.X, margin=5)
        self.next_step_button = ttk.Button(run_frame, text="Następny krok", command=self.next_step, state=tk.DISABLED)
        self.next_step_button.pack(fill=tk.X, margin=5)
        self.reset_button = ttk.Button(run_frame, text="Resetuj", command=self.reset_search, state=tk.DISABLED)
        self.reset_button.pack(fill=tk.X, margin=5)

        # Sekcja 5: Status
        status_frame = ttk.LabelFrame(control_panel, text="Status")
        status_frame.pack(fill=tk.X, pady=10)
        self.status_label = ttk.Label(status_frame, text="Wybierz plik z grafem.", wraplength=230)
        self.status_label.pack(fill=tk.X, margin=5)

    def load_graph(self):
        """Wczytuje i parsuje plik grafu."""
        filepath = filedialog.askopenfilename(filetypes=[("Pliki tekstowe", "*.txt")])
        if not filepath:
            return

        try:
            with open(filepath, 'r') as f:
                n = int(f.readline().strip())
                coords = [tuple(map(int, f.readline().strip().split())) for _ in range(n)]
                adj = []
                for _ in range(n):
                    # Plik jest 1-indeksowany, konwertujemy na 0-indeksowany
                    neighbors = [int(v) - 1 for v in f.readline().strip().split()[1:]]
                    adj.append(neighbors)
            
            self.num_nodes = n
            self.coordinates = coords
            self.adj_list = adj
            self.graph_label.config(text=f"Wczytano: {n} wierzchołków.")
            self.start_button.config(state=tk.NORMAL)
            self.reset_button.config(state=tk.NORMAL)
            self.reset_search()
        except Exception as e:
            messagebox.showerror("Błąd pliku", f"Nie można wczytać pliku:\n{e}")

    def get_canvas_coords(self, node_idx):
        """Konwertuje współrzędne logiczne na współrzędne płótna."""
        x, y = self.coordinates[node_idx]
        return PADDING + x * SCALE, PADDING + y * SCALE

    def draw_graph(self, highlight_nodes=None, highlight_path=None):
        """Rysuje graf na płótnie, kolorując wierzchołki wg stanu."""
        self.canvas.delete("all")
        if self.num_nodes == 0:
            return

        # 1. Rysuj krawędzie (pod spodem)
        for i, neighbors in enumerate(self.adj_list):
            x1, y1 = self.get_canvas_coords(i)
            for neighbor_idx in neighbors:
                if neighbor_idx > i: # Rysuj krawędź tylko raz
                    x2, y2 = self.get_canvas_coords(neighbor_idx)
                    self.canvas.create_line(x1, y1, x2, y2, fill=LINE_COLOR, width=2)
        
        # 2. Rysuj krawędzie ścieżki (na wierzchu)
        if highlight_path:
            for i in range(len(highlight_path) - 1):
                x1, y1 = self.get_canvas_coords(highlight_path[i])
                x2, y2 = self.get_canvas_coords(highlight_path[i+1])
                self.canvas.create_line(x1, y1, x2, y2, fill=PATH_LINE_COLOR, width=4)

        # 3. Rysuj wierzchołki
        for i in range(self.num_nodes):
            x, y = self.get_canvas_coords(i)
            
            # Uproszczona logika wyboru koloru
            state = 'default'
            if highlight_nodes:
                if i in highlight_nodes.get('path', set()): state = 'path'
                elif i == highlight_nodes.get('current'): state = 'current'
                elif i in highlight_nodes.get('visited', set()): state = 'visited'
                elif i in highlight_nodes.get('frontier', set()): state = 'frontier'
            
            if i == self.start_idx: state = 'start'
            if i == self.goal_idx: state = 'goal'
            
            fill_color = STATE_COLORS[state]
            
            self.canvas.create_oval(
                x - NODE_RADIUS, y - NODE_RADIUS, x + NODE_RADIUS, y + NODE_RADIUS,
                fill=fill_color, outline='black', width=2
            )
            # Wyświetlamy numery 1-indeksowane
            self.canvas.create_text(x, y, text=str(i + 1), font=("Arial", 10, "bold"))

    def reset_search(self):
        """Resetuje stan algorytmu i GUI."""
        self.search_generator = None
        self.start_idx = -1
        self.goal_idx = -1
        self.start_entry.delete(0, tk.END)
        self.goal_entry.delete(0, tk.END)
        self.status_label.config(text="Gotowy. Wybierz start i cel.")
        self.start_button.config(state=tk.NORMAL if self.num_nodes > 0 else tk.DISABLED)
        self.next_step_button.config(state=tk.DISABLED)
        self.draw_graph()

    def start_search(self):
        """Rozpoczyna nowy proces wyszukiwania."""
        try:
            # Konwersja 1-indeksowanego wejścia na 0-indeksowane
            self.start_idx = int(self.start_entry.get()) - 1
            self.goal_idx = int(self.goal_entry.get()) - 1
            if not (0 <= self.start_idx < self.num_nodes and 0 <= self.goal_idx < self.num_nodes):
                raise ValueError("Numery wierzchołków poza zakresem.")
        except ValueError as e:
            messagebox.showerror("Błędne dane", f"Nieprawidłowy numer start/cel.\n{e}")
            return

        algo_type = self.algo_var.get()
        # Tworzymy generator, który będzie zwracał kolejne kroki
        self.search_generator = self.run_search_generator(self.start_idx, self.goal_idx, algo_type)
        
        self.start_button.config(state=tk.DISABLED)
        self.next_step_button.config(state=tk.NORMAL)
        self.status_label.config(text=f"Start: {algo_type}. Klikaj 'Następny krok'.")
        self.draw_graph() # Prerysuj, by pokazać start/cel

    def next_step(self):
        """Wykonuje jeden krok algorytmu z generatora."""
        if not self.search_generator:
            return
            
        try:
            step_data = next(self.search_generator)
            
            if step_data['status'] == 'running':
                highlights = {
                    'current': step_data['current'],
                    'visited': step_data['visited'],
                    'frontier': step_data['frontier']
                }
                self.draw_graph(highlight_nodes=highlights)
                self.status_label.config(text=f"Przetwarzanie: wierzchołek {step_data['current'] + 1}")
            
            elif step_data['status'] == 'found':
                self.show_final_path(step_data['path_data'])
                self.status_label.config(text="Sukces! Znaleziono ścieżkę.")
                self.next_step_button.config(state=tk.DISABLED)
            
            elif step_data['status'] == 'not_found':
                messagebox.showinfo("Brak ścieżki", "Nie znaleziono ścieżki do celu.")
                self.reset_search()
                
        except StopIteration:
            # Generator się skończył
            self.next_step_button.config(state=tk.DISABLED)

    def show_final_path(self, path_data):
        """Odtwarza ścieżkę i wyświetla koszt."""
        came_from, cost_so_far = path_data
        
        # Odtwórz ścieżkę
        path = []
        current = self.goal_idx
        while current is not None:
            path.append(current)
            current = came_from.get(current, None)
        path.reverse() # Od startu do celu

        if self.goal_idx in cost_so_far:
            cost = cost_so_far[self.goal_idx]
            self.status_label.config(text=f"Ścieżka znaleziona! Długość: {cost:.4f}")
        
        # Narysuj graf z podświetloną ścieżką
        highlights = {'path': path}
        self.draw_graph(highlight_nodes=highlights, highlight_path=path)

    def get_distance(self, idx1, idx2):
        """Zwraca koszt (odległość euklidesową) między dwoma wierzchołkami."""
        x1, y1 = self.coordinates[idx1]
        x2, y2 = self.coordinates[idx2]
        return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)

    def run_search_generator(self, start_idx, goal_idx, algorithm_type):
        """
        Rdzeń logiki A* / GBFS jako generator. Zwraca (yield) stan po
        każdym przetworzonym wierzchołku.
        """
        
        # Kolejka priorytetowa (f, wierzchołek)
        frontier = []
        heapq.heappush(frontier, (0, start_idx))
        
        # Wymagane mapy
        came_from = {start_idx: None}
        cost_so_far = {start_idx: 0} # g(n)
        
        visited_nodes = set()

        while frontier:
            _, current_idx = heapq.heappop(frontier) # Pobierz wierzchołek
            
            if current_idx in visited_nodes:
                continue
            visited_nodes.add(current_idx)

            # --- KROK WIZUALIZACJI ---
            # Zwróć aktualny stan do GUI i poczekaj na 'next_step()'
            yield {
                'status': 'running',
                'current': current_idx,
                'visited': visited_nodes,
                'frontier': {node for (_, node) in frontier}
            }

            # 3. Sprawdzenie celu
            if current_idx == goal_idx:
                yield {'status': 'found', 'path_data': (came_from, cost_so_far)}
                return

            # 4. Przetwórz sąsiadów
            for neighbor_idx in self.adj_list[current_idx]:
                # g(n) = koszt do teraz + koszt krawędzi
                new_cost = cost_so_far[current_idx] + self.get_distance(current_idx, neighbor_idx)
                
                if neighbor_idx not in cost_so_far or new_cost < cost_so_far[neighbor_idx]:
                    # Aktualizuj mapy
                    cost_so_far[neighbor_idx] = new_cost
                    came_from[neighbor_idx] = current_idx
                    
                    # h(n) - heurystyka (zawsze ta sama)
                    h = self.get_distance(neighbor_idx, goal_idx)
                    
                    # f(n) - priorytet (zależny od algorytmu)
                    f = (new_cost + h) if algorithm_type == "A*" else h
                    
                    heapq.heappush(frontier, (f, neighbor_idx))
        
        # Koniec pętli - nie znaleziono celu
        yield {'status': 'not_found'}

# --- Uruchomienie aplikacji ---
if __name__ == "__main__":
    root = tk.Tk()
    app = GraphSearchApp(root)
    root.mainloop()
